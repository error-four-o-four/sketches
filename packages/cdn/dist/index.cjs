"use strict";var v=Object.defineProperty;var n=(s,t)=>v(s,"name",{value:t,configurable:!0});var u=require("node:path"),c=require("node:fs");const j="libs.json",p={base:"https://cdnjs.cloudflare.com/ajax/libs",api:"https://api.cdnjs.com/libraries"},w={initial:["name","version","filename","sri"],version:["name","sri"]};function b(s){try{const t=c.readFileSync(s,"utf-8");return JSON.parse(t)}catch(t){f(t)}return null}n(b,"parseJson");function g(s,t){c.writeFileSync(s,JSON.stringify(t,null,2))}n(g,"writeJson");async function S(s){try{return await(await fetch(s)).json()}catch(t){f(t)}return null}n(S,"fetchRequest");function f(s){s instanceof Error&&console.log(s.message)}n(f,"logError");function $(s){const t=Object.entries(s),e=new Set;return t.forEach(([i,a])=>{const{filename:o}=a,r=Object.keys(a.versions);for(const l of r){const d=`/${i}/${l}/${o}`;e.add(d)}}),e}n($,"createLibraryKeys");async function h(s,t){const e=t?`${s}/${t}`:s,i=t?w.version:w.initial,a=`${p.api}/${e}?fields=${i.join(",")}`;console.log("Fetching data from %o ...",a);const o=await S(a);return o||(console.log("Could not fetch library data!"),process.exit(1)),"error"in o&&(console.log(o.status,o.message),process.exit(1)),o}n(h,"fetchLibraryData");function y(s,t,e){if(e="filename"in s?s.filename:e,!e)throw new Error("Filename of %o is required!");return{url:`${p.base}/${s.name}/${t}/${e}`,sri:typeof s.sri=="string"?s.sri:s.sri[e]}}n(y,"parseFetchedData");class x{static{n(this,"LibHandler")}path;file;data;keys;constructor(t){this.path=t,this.file=u.join(t,j),this.data=b(this.file)??{},this.keys=$(this.data)}async createLibraryData(t){const e=await h(t,null);this.data[t]={latest:e.version,filename:e.filename,versions:{[e.version]:y(e,e.version)},updatedAt:new Date().toISOString()}}async updateLibraryData(t,e){const i=this.data[t],a=new Date(i.updatedAt).valueOf(),o=Date.now()-a>1e3*60*60*24*31;if(!e&&!o&&i.latest&&(console.log("Latest version %o of %o has already been fetched",i.latest,t),process.exit(0)),!e&&o){const r=await h(t,null);r.version===i.latest&&r.version in i.versions&&(console.log("Latest version %o of %o has already been fetched",i.latest,t),process.exit(0)),i.latest=r.version,i.versions[r.version]=y(r,r.version),i.updatedAt=new Date().toISOString(),this.data[t]=i;return}if(e){Object.keys(i.versions).includes(e)&&(console.log("Version %o of %o has already been fetched",e,t),process.exit(0));const l=await h(t,e);this.data[t].versions[e]=y(l,e,i.filename);return}console.log("Something went wrong ..."),process.exit(1)}async download(t,e,i){const a=u.join(this.path,t,e),o=u.resolve(a,i);c.existsSync(o)&&(console.log("Version %o of %o has already been downloaded",e,t),process.exit(0)),c.mkdirSync(a,{recursive:!0});try{const r=this.data[t].versions[e].url,d=await(await fetch(r)).text();c.writeFileSync(o,d,"utf-8")}catch(r){f(r),process.exit(1)}}async fetch(t,e){Object.hasOwn(this.data,t)||await this.createLibraryData(t),e&&await this.updateLibraryData(t,e),g(this.file,this.data),e=e||this.data[t].latest,await this.download(t,e,this.data[t].filename),console.log("\u2705 Done")}has(t){return this.keys.has(t)}get(t){if(!this.keys.has(t))return null;const[e,i]=t.slice(1).split("/"),a=e in this.data?this.data[e]:null;return a?a.versions[i]??null:null}}exports.LibHandler=x,exports.logError=f,exports.parseJson=b,exports.writeJson=g;
