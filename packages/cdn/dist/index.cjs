"use strict";var v=Object.defineProperty;var r=(e,t)=>v(e,"name",{value:t,configurable:!0});var f=require("node:path"),c=require("node:fs");const j="libs.json",w={base:"https://cdnjs.cloudflare.com/ajax/libs",api:"https://api.cdnjs.com/libraries"},p={initial:["name","version","filename","sri"],version:["name","sri"]};function b(e){try{const t=c.readFileSync(e,"utf-8");return JSON.parse(t)}catch(t){l(t)}return null}r(b,"parseJson");function g(e,t){c.writeFileSync(e,JSON.stringify(t,null,2))}r(g,"writeJson");async function S(e){try{return await(await fetch(e)).json()}catch(t){l(t)}return null}r(S,"fetchRequest");function l(e){e instanceof Error&&console.log(e.message)}r(l,"logError");function $(e){const t=Object.entries(e),s=new Set;return t.forEach(([i,o])=>{const{filename:n}=o,a=Object.keys(o.versions);for(const y of a){const u=`/${i}/${y}/${n}`;s.add(u)}}),s}r($,"createLibraryKeys");async function O(e){const t=await h(e,null);return{latest:t.version,filename:t.filename,versions:{[t.version]:d(t,t.version)},updatedAt:new Date().toISOString()}}r(O,"createLibraryData");async function D(e,t,s){const i=new Date(e.updatedAt).valueOf(),o=Date.now()-i>1e3*60*60*24*31;if(!s&&!o&&e.latest)return console.log("Latest version %o of %o has already been fetched",e.latest,t),null;if(!s&&o){const n=await h(t,null);return n.version===e.latest&&n.version in e.versions?(console.log("Latest version %o of %o has already been fetched",e.latest,t),null):(e.latest=n.version,e.versions[n.version]=d(n,n.version),e.updatedAt=new Date().toISOString(),e)}if(s){if(Object.keys(e.versions).includes(s))return console.log("Version %o of %o has already been fetched",s,t),null;const a=await h(t,s);return e.versions[s]=d(a,s,e.filename),e}console.log("Something went wrong ..."),process.exit(1)}r(D,"updateLibraryData");async function h(e,t){const s=t?`${e}/${t}`:e,i=t?p.version:p.initial,o=`${w.api}/${s}?fields=${i.join(",")}`;console.log("Fetching data from %o ...",o);const n=await S(o);return n||(console.log("Could not fetch library data!"),process.exit(1)),"error"in n&&(console.log(n.status,n.message),process.exit(1)),n}r(h,"fetchLibraryData");function d(e,t,s){if(s="filename"in e?e.filename:s,!s)throw new Error("Filename of %o is required!");return{url:`${w.base}/${e.name}/${t}/${s}`,sri:typeof e.sri=="string"?e.sri:e.sri[s]}}r(d,"parseFetchedData");class k{static{r(this,"LibHandler")}path;file;data;keys;constructor(t){this.path=t,this.file=f.join(t,j),this.data=b(this.file)??{},this.keys=$(this.data)}async download(t,s,i){const o=f.join(this.path,t,s),n=f.resolve(o,i);c.existsSync(n)&&(console.log("Version %o of %o has already been downloaded",s,t),process.exit(0)),c.mkdirSync(o,{recursive:!0});try{const a=this.data[t].versions[s].url,u=await(await fetch(a)).text();c.writeFileSync(n,u,"utf-8")}catch(a){l(a),process.exit(1)}}async fetch(t,s){if(!Object.hasOwn(this.data,t)){const i=await O(t);i&&(this.data[t]=i)}if(s){const i=await D(this.data[t],t,s);i&&(this.data[t]=i)}g(this.file,this.data),s=s||this.data[t].latest,await this.download(t,s,this.data[t].filename),console.log("\u2705 Done")}has(t){return this.keys.has(t)}get(t){if(!this.keys.has(t))return null;const[s,i]=t.slice(1).split("/"),o=s in this.data?this.data[s]:null;return o?o.versions[i]??null:null}}exports.LibHandler=k,exports.logError=l,exports.parseJson=b,exports.writeJson=g;
