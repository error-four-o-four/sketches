"use strict";var w=Object.defineProperty;var n=(i,t)=>w(i,"name",{value:t,configurable:!0});var h=require("node:path"),f=require("node:fs"),l=require("@internal/utils");const g="libs.json",p={base:"https://cdnjs.cloudflare.com/ajax/libs",api:"https://api.cdnjs.com/libraries"},b={initial:["name","version","filename","sri"],version:["name","sri"]};function v(i){const t=Object.entries(i),e=new Set;return t.forEach(([s,a])=>{const{filename:o}=a,r=Object.keys(a.versions);for(const c of r){const d=`/${s}/${c}/${o}`;e.add(d)}}),e}n(v,"createLibraryKeys");async function u(i,t){const e=t?`${i}/${t}`:i,s=t?b.version:b.initial,a=`${p.api}/${e}?fields=${s.join(",")}`;console.log("Fetching data from %o ...",a);const o=await j(a);return o||(console.log("Could not fetch library data!"),process.exit(1)),"error"in o&&(console.log(o.status,o.message),process.exit(1)),o}n(u,"fetchLibraryData");async function j(i){try{return await(await fetch(i)).json()}catch(t){l.logError(t)}return null}n(j,"fetchRequest");function y(i,t,e){if(e="filename"in i?i.filename:e,!e)throw new Error("Filename of %o is required!");return{url:`${p.base}/${i.name}/${t}/${e}`,sri:typeof i.sri=="string"?i.sri:i.sri[e]}}n(y,"parseFetchedData");class ${static{n(this,"LibHandler")}path;file;data;keys;constructor(t){this.path=t,this.file=h.join(t,g),this.data=l.parseJson(this.file)??{},this.keys=v(this.data)}async createLibraryData(t){const e=await u(t,null);this.data[t]={latest:e.version,filename:e.filename,versions:{[e.version]:y(e,e.version)},updatedAt:new Date().toISOString()}}async updateLibraryData(t,e){const s=this.data[t],a=new Date(s.updatedAt).valueOf(),o=Date.now()-a>1e3*60*60*24*31;if(!e&&!o&&s.latest&&(console.log("Latest version %o of %o has already been fetched",s.latest,t),process.exit(0)),!e&&o){const r=await u(t,null);r.version===s.latest&&r.version in s.versions&&(console.log("Latest version %o of %o has already been fetched",s.latest,t),process.exit(0)),s.latest=r.version,s.versions[r.version]=y(r,r.version),s.updatedAt=new Date().toISOString(),this.data[t]=s;return}if(e){Object.keys(s.versions).includes(e)&&(console.log("Version %o of %o has already been fetched",e,t),process.exit(0));const c=await u(t,e);this.data[t].versions[e]=y(c,e,s.filename);return}console.log("Something went wrong ..."),process.exit(1)}async download(t,e,s){const a=h.join(this.path,t,e),o=h.resolve(a,s);f.existsSync(o)&&(console.log("Version %o of %o has already been downloaded",e,t),process.exit(0)),f.mkdirSync(a,{recursive:!0});try{const r=this.data[t].versions[e].url,d=await(await fetch(r)).text();f.writeFileSync(o,d,"utf-8")}catch(r){l.logError(r),process.exit(1)}}async fetch(t,e){Object.hasOwn(this.data,t)||await this.createLibraryData(t),e&&await this.updateLibraryData(t,e),l.writeJson(this.file,this.data),e=e||this.data[t].latest,await this.download(t,e,this.data[t].filename),console.log("\u2705 Done")}has(t){return this.keys.has(t)}get(t){if(!this.keys.has(t))return null;const[e,s]=t.slice(1).split("/"),a=e in this.data?this.data[e]:null;return a?a.versions[s]??null:null}}exports.LibHandler=$;
