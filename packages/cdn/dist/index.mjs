var j=Object.defineProperty;var r=(s,t)=>j(s,"name",{value:t,configurable:!0});import d from"node:path";import h,{readFileSync as v,writeFileSync as S}from"node:fs";const x="libs.json",p={base:"https://cdnjs.cloudflare.com/ajax/libs",api:"https://api.cdnjs.com/libraries"},w={initial:["name","version","filename","sri"],version:["name","sri"]};function b(s){try{const t=v(s,"utf-8");return JSON.parse(t)}catch(t){l(t)}return null}r(b,"parseJson");function g(s,t){S(s,JSON.stringify(t,null,2))}r(g,"writeJson");async function $(s){try{return await(await fetch(s)).json()}catch(t){l(t)}return null}r($,"fetchRequest");function l(s){s instanceof Error&&console.log(s.message)}r(l,"logError");function D(s){const t=Object.entries(s),e=new Set;return t.forEach(([i,o])=>{const{filename:a}=o,n=Object.keys(o.versions);for(const c of n){const f=`/${i}/${c}/${a}`;e.add(f)}}),e}r(D,"createLibraryKeys");async function u(s,t){const e=t?`${s}/${t}`:s,i=t?w.version:w.initial,o=`${p.api}/${e}?fields=${i.join(",")}`;console.log("Fetching data from %o ...",o);const a=await $(o);return a||(console.log("Could not fetch library data!"),process.exit(1)),"error"in a&&(console.log(a.status,a.message),process.exit(1)),a}r(u,"fetchLibraryData");function y(s,t,e){if(e="filename"in s?s.filename:e,!e)throw new Error("Filename of %o is required!");return{url:`${p.base}/${s.name}/${t}/${e}`,sri:typeof s.sri=="string"?s.sri:s.sri[e]}}r(y,"parseFetchedData");class O{static{r(this,"LibHandler")}path;file;data;keys;constructor(t){this.path=t,this.file=d.join(t,x),this.data=b(this.file)??{},this.keys=D(this.data)}async createLibraryData(t){const e=await u(t,null);this.data[t]={latest:e.version,filename:e.filename,versions:{[e.version]:y(e,e.version)},updatedAt:new Date().toISOString()}}async updateLibraryData(t,e){const i=this.data[t],o=new Date(i.updatedAt).valueOf(),a=Date.now()-o>1e3*60*60*24*31;if(!e&&!a&&i.latest&&(console.log("Latest version %o of %o has already been fetched",i.latest,t),process.exit(0)),!e&&a){const n=await u(t,null);n.version===i.latest&&n.version in i.versions&&(console.log("Latest version %o of %o has already been fetched",i.latest,t),process.exit(0)),i.latest=n.version,i.versions[n.version]=y(n,n.version),i.updatedAt=new Date().toISOString(),this.data[t]=i;return}if(e){Object.keys(i.versions).includes(e)&&(console.log("Version %o of %o has already been fetched",e,t),process.exit(0));const c=await u(t,e);this.data[t].versions[e]=y(c,e,i.filename);return}console.log("Something went wrong ..."),process.exit(1)}async download(t,e,i){const o=d.join(this.path,t,e),a=d.resolve(o,i);h.existsSync(a)&&(console.log("Version %o of %o has already been downloaded",e,t),process.exit(0)),h.mkdirSync(o,{recursive:!0});try{const n=this.data[t].versions[e].url,f=await(await fetch(n)).text();h.writeFileSync(a,f,"utf-8")}catch(n){l(n),process.exit(1)}}async fetch(t,e){Object.hasOwn(this.data,t)||await this.createLibraryData(t),e&&await this.updateLibraryData(t,e),g(this.file,this.data),e=e||this.data[t].latest,await this.download(t,e,this.data[t].filename),console.log("\u2705 Done")}has(t){return this.keys.has(t)}get(t){if(!this.keys.has(t))return null;const[e,i]=t.slice(1).split("/"),o=e in this.data?this.data[e]:null;return o?o.versions[i]??null:null}}export{O as LibHandler,l as logError,b as parseJson,g as writeJson};
