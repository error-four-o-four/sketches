var j=Object.defineProperty;var r=(e,t)=>j(e,"name",{value:t,configurable:!0});import f from"node:path";import u,{readFileSync as v,writeFileSync as S}from"node:fs";const $="libs.json",p={base:"https://cdnjs.cloudflare.com/ajax/libs",api:"https://api.cdnjs.com/libraries"},w={initial:["name","version","filename","sri"],version:["name","sri"]};function b(e){try{const t=v(e,"utf-8");return JSON.parse(t)}catch(t){c(t)}return null}r(b,"parseJson");function g(e,t){S(e,JSON.stringify(t,null,2))}r(g,"writeJson");async function O(e){try{return await(await fetch(e)).json()}catch(t){c(t)}return null}r(O,"fetchRequest");function c(e){e instanceof Error&&console.log(e.message)}r(c,"logError");function x(e){const t=Object.entries(e),s=new Set;return t.forEach(([o,i])=>{const{filename:n}=i,a=Object.keys(i.versions);for(const y of a){const l=`/${o}/${y}/${n}`;s.add(l)}}),s}r(x,"createLibraryKeys");async function D(e){const t=await h(e,null);return{latest:t.version,filename:t.filename,versions:{[t.version]:d(t,t.version)},updatedAt:new Date().toISOString()}}r(D,"createLibraryData");async function k(e,t,s){const o=new Date(e.updatedAt).valueOf(),i=Date.now()-o>1e3*60*60*24*31;if(!s&&!i&&e.latest)return console.log("Latest version %o of %o has already been fetched",e.latest,t),null;if(!s&&i){const n=await h(t,null);return n.version===e.latest&&n.version in e.versions?(console.log("Latest version %o of %o has already been fetched",e.latest,t),null):(e.latest=n.version,e.versions[n.version]=d(n,n.version),e.updatedAt=new Date().toISOString(),e)}if(s){if(Object.keys(e.versions).includes(s))return console.log("Version %o of %o has already been fetched",s,t),null;const a=await h(t,s);return e.versions[s]=d(a,s,e.filename),e}console.log("Something went wrong ..."),process.exit(1)}r(k,"updateLibraryData");async function h(e,t){const s=t?`${e}/${t}`:e,o=t?w.version:w.initial,i=`${p.api}/${s}?fields=${o.join(",")}`;console.log("Fetching data from %o ...",i);const n=await O(i);return n||(console.log("Could not fetch library data!"),process.exit(1)),"error"in n&&(console.log(n.status,n.message),process.exit(1)),n}r(h,"fetchLibraryData");function d(e,t,s){if(s="filename"in e?e.filename:s,!s)throw new Error("Filename of %o is required!");return{url:`${p.base}/${e.name}/${t}/${s}`,sri:typeof e.sri=="string"?e.sri:e.sri[s]}}r(d,"parseFetchedData");class L{static{r(this,"LibHandler")}path;file;data;keys;constructor(t){this.path=t,this.file=f.join(t,$),this.data=b(this.file)??{},this.keys=x(this.data)}async download(t,s,o){const i=f.join(this.path,t,s),n=f.resolve(i,o);u.existsSync(n)&&(console.log("Version %o of %o has already been downloaded",s,t),process.exit(0)),u.mkdirSync(i,{recursive:!0});try{const a=this.data[t].versions[s].url,l=await(await fetch(a)).text();u.writeFileSync(n,l,"utf-8")}catch(a){c(a),process.exit(1)}}async fetch(t,s){if(!Object.hasOwn(this.data,t)){const o=await D(t);o&&(this.data[t]=o)}if(s){const o=await k(this.data[t],t,s);o&&(this.data[t]=o)}g(this.file,this.data),s=s||this.data[t].latest,await this.download(t,s,this.data[t].filename),console.log("\u2705 Done")}has(t){return this.keys.has(t)}get(t){if(!this.keys.has(t))return null;const[s,o]=t.slice(1).split("/"),i=s in this.data?this.data[s]:null;return i?i.versions[o]??null:null}}export{L as LibHandler,c as logError,b as parseJson,g as writeJson};
