var b=Object.defineProperty;var n=(i,t)=>b(i,"name",{value:t,configurable:!0});import d from"node:path";import f from"node:fs";import{logError as y,parseJson as g,writeJson as j}from"@internal/utils";const v="libs.json",p={base:"https://cdnjs.cloudflare.com/ajax/libs",api:"https://api.cdnjs.com/libraries"},w={initial:["name","version","filename","sri"],version:["name","sri"]};function x(i){const t=Object.entries(i),s=new Set;return t.forEach(([e,o])=>{const{filename:a}=o,r=Object.keys(o.versions);for(const c of r){const l=`/${e}/${c}/${a}`;s.add(l)}}),s}n(x,"createLibraryKeys");async function h(i,t){const s=t?`${i}/${t}`:i,e=t?w.version:w.initial,o=`${p.api}/${s}?fields=${e.join(",")}`;console.log("Fetching data from %o ...",o);const a=await $(o);return a||(console.log("Could not fetch library data!"),process.exit(1)),"error"in a&&(console.log(a.status,a.message),process.exit(1)),a}n(h,"fetchLibraryData");async function $(i){try{return await(await fetch(i)).json()}catch(t){y(t)}return null}n($,"fetchRequest");function u(i,t,s){if(s="filename"in i?i.filename:s,!s)throw new Error("Filename of %o is required!");return{url:`${p.base}/${i.name}/${t}/${s}`,sri:typeof i.sri=="string"?i.sri:i.sri[s]}}n(u,"parseFetchedData");class D{static{n(this,"LibHandler")}path;file;data;keys;constructor(t){this.path=t,this.file=d.join(t,v),this.data=g(this.file)??{},this.keys=x(this.data)}async createLibraryData(t){const s=await h(t,null);this.data[t]={latest:s.version,filename:s.filename,versions:{[s.version]:u(s,s.version)},updatedAt:new Date().toISOString()}}async updateLibraryData(t,s){const e=this.data[t],o=new Date(e.updatedAt).valueOf(),a=Date.now()-o>1e3*60*60*24*31;if(!s&&!a&&e.latest&&(console.log("Latest version %o of %o has already been fetched",e.latest,t),process.exit(0)),!s&&a){const r=await h(t,null);r.version===e.latest&&r.version in e.versions&&(console.log("Latest version %o of %o has already been fetched",e.latest,t),process.exit(0)),e.latest=r.version,e.versions[r.version]=u(r,r.version),e.updatedAt=new Date().toISOString(),this.data[t]=e;return}if(s){Object.keys(e.versions).includes(s)&&(console.log("Version %o of %o has already been fetched",s,t),process.exit(0));const c=await h(t,s);this.data[t].versions[s]=u(c,s,e.filename);return}console.log("Something went wrong ..."),process.exit(1)}async download(t,s,e){const o=d.join(this.path,t,s),a=d.resolve(o,e);f.existsSync(a)&&(console.log("Version %o of %o has already been downloaded",s,t),process.exit(0)),f.mkdirSync(o,{recursive:!0});try{const r=this.data[t].versions[s].url,l=await(await fetch(r)).text();f.writeFileSync(a,l,"utf-8")}catch(r){y(r),process.exit(1)}}async fetch(t,s){Object.hasOwn(this.data,t)||await this.createLibraryData(t),s&&await this.updateLibraryData(t,s),j(this.file,this.data),s=s||this.data[t].latest,await this.download(t,s,this.data[t].filename),console.log("\u2705 Done")}has(t){return this.keys.has(t)}get(t){if(!this.keys.has(t))return null;const[s,e]=t.slice(1).split("/"),o=s in this.data?this.data[s]:null;return o?o.versions[e]??null:null}}export{D as LibHandler};
